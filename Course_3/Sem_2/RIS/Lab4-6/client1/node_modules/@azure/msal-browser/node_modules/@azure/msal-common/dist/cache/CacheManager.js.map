{"version":3,"file":"CacheManager.js","sources":["../../src/cache/CacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountCache, AccountFilter, CredentialFilter, CredentialCache, ValidCredentialType, AppMetadataFilter, AppMetadataCache } from \"./utils/CacheTypes\";\nimport { CacheRecord } from \"./entities/CacheRecord\";\nimport { CacheSchemaType, CredentialType, Constants, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from \"../utils/Constants\";\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\nimport { ScopeSet } from \"../request/ScopeSet\";\nimport { AccountEntity } from \"./entities/AccountEntity\";\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\nimport { AuthError } from \"../error/AuthError\";\nimport { ICacheManager } from \"./interface/ICacheManager\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\nimport { AuthToken } from \"../account/AuthToken\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\n\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n */\nexport abstract class CacheManager implements ICacheManager {\n    protected clientId: string;\n    protected cryptoImpl: ICrypto;\n\n    constructor(clientId: string, cryptoImpl: ICrypto) {\n        this.clientId = clientId;\n        this.cryptoImpl = cryptoImpl;\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     *  @param accountKey\n     */\n    abstract getAccount(accountKey: string): AccountEntity | null;\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    abstract setAccount(account: AccountEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param idTokenKey\n     */\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param idToken\n     */\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param accessTokenKey\n     */\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param accessToken\n     */\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param refreshTokenKey\n     */\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param refreshToken\n     */\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\n\n    /**\n     * fetch cloud discovery metadata entity from the platform cache\n     * @param key\n     */\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\n\n    /**\n     *\n     */\n    abstract getAuthorityMetadataKeys(): Array<string>;\n\n    /**\n     * set cloud discovery metadata entity to the platform cache\n     * @param key\n     * @param value\n     */\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;;\n\n    /**\n     * Function to remove an item from cache given its key.\n     * @param key\n     */\n    abstract removeItem(key: string, type?: string): boolean;\n\n    /**\n     * Function which returns boolean whether cache contains a specific key.\n     * @param key\n     */\n    abstract containsKey(key: string, type?: string): boolean;\n\n    /**\n     * Function which retrieves all current keys from the cache.\n     */\n    abstract getKeys(): string[];\n\n    /**\n     * Function which clears cache.\n     */\n    abstract clear(): Promise<void>;\n\n    /**\n     * Function which updates an outdated credential cache key\n     */\n    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;\n\n    /**\n     * Returns all accounts in cache\n     */\n    getAllAccounts(): AccountInfo[] {\n        const currentAccounts: AccountCache = this.getAccountsFilteredBy();\n        const accountValues: AccountEntity[] = Object.keys(currentAccounts).map(accountKey => currentAccounts[accountKey]);\n        const numAccounts = accountValues.length;\n        if (numAccounts < 1) {\n            return [];\n        } else {\n            const allAccounts = accountValues.map<AccountInfo>((value) => {\n                const accountEntity = CacheManager.toObject<AccountEntity>(new AccountEntity(), value);\n                const accountInfo = accountEntity.getAccountInfo();\n                const idToken = this.readIdTokenFromCache(this.clientId, accountInfo);\n                if (idToken && !accountInfo.idTokenClaims) {\n                    accountInfo.idToken = idToken.secret;\n                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n                }\n\n                return accountInfo;\n\n            });\n            return allAccounts;\n        }\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord\n     */\n    async saveCacheRecord(cacheRecord: CacheRecord): Promise<void> {\n        if (!cacheRecord) {\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\n        }\n\n        if (!!cacheRecord.account) {\n            this.setAccount(cacheRecord.account);\n        }\n\n        if (!!cacheRecord.idToken) {\n            this.setIdTokenCredential(cacheRecord.idToken);\n        }\n\n        if (!!cacheRecord.accessToken) {\n            await this.saveAccessToken(cacheRecord.accessToken);\n        }\n\n        if (!!cacheRecord.refreshToken) {\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\n        }\n\n        if (!!cacheRecord.appMetadata) {\n            this.setAppMetadata(cacheRecord.appMetadata);\n        }\n    }\n\n    /**\n     * saves access token credential\n     * @param credential\n     */\n    private async saveAccessToken(credential: AccessTokenEntity): Promise<void> {\n        const currentTokenCache = this.getCredentialsFilteredBy({\n            clientId: credential.clientId,\n            credentialType: credential.credentialType,\n            environment: credential.environment,\n            homeAccountId: credential.homeAccountId,\n            realm: credential.realm,\n            tokenType: credential.tokenType,\n            requestedClaimsHash: credential.requestedClaimsHash\n        });\n\n        const currentScopes = ScopeSet.fromString(credential.target);\n        const currentAccessTokens: AccessTokenEntity[] = Object.keys(currentTokenCache.accessTokens).map(key => currentTokenCache.accessTokens[key]);\n\n        if (currentAccessTokens) {\n            const removedAccessTokens: Array<Promise<boolean>> = [];\n            currentAccessTokens.forEach((tokenEntity) => {\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                    removedAccessTokens.push(this.removeCredential(tokenEntity));\n                }\n            });\n            await Promise.all(removedAccessTokens);\n        }\n        this.setAccessTokenCredential(credential);\n    }\n\n    /**\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param homeAccountId\n     * @param environment\n     * @param realm\n     */\n    getAccountsFilteredBy(accountFilter?: AccountFilter): AccountCache {\n        return this.getAccountsFilteredByInternal(\n            accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING,\n            accountFilter ? accountFilter.environment : Constants.EMPTY_STRING,\n            accountFilter ? accountFilter.realm : Constants.EMPTY_STRING,\n            accountFilter ? accountFilter.nativeAccountId: Constants.EMPTY_STRING,\n        );\n    }\n\n    /**\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param homeAccountId\n     * @param environment\n     * @param realm\n     */\n    private getAccountsFilteredByInternal(\n        homeAccountId?: string,\n        environment?: string,\n        realm?: string,\n        nativeAccountId?: string,\n    ): AccountCache {\n        const allCacheKeys = this.getKeys();\n        const matchingAccounts: AccountCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!homeAccountId && !this.matchHomeAccountId(entity, homeAccountId)) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!realm && !this.matchRealm(entity, realm)) {\n                return;\n            }\n\n            if (!!nativeAccountId && !this.matchNativeAccountId(entity, nativeAccountId)) {\n                return;\n            }\n\n            matchingAccounts[cacheKey] = entity;\n        });\n\n        return matchingAccounts;\n    }\n\n    /**\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\n     * @param homeAccountId\n     * @param environment\n     * @param credentialType\n     * @param clientId\n     * @param realm\n     * @param target\n     */\n    getCredentialsFilteredBy(filter: CredentialFilter): CredentialCache {\n        return this.getCredentialsFilteredByInternal(\n            filter.homeAccountId,\n            filter.environment,\n            filter.credentialType,\n            filter.clientId,\n            filter.familyId,\n            filter.realm,\n            filter.target,\n            filter.userAssertionHash,\n            filter.tokenType,\n            filter.keyId,\n            filter.requestedClaimsHash\n        );\n    }\n\n    /**\n     * Support function to help match credentials\n     * @param homeAccountId\n     * @param environment\n     * @param credentialType\n     * @param clientId\n     * @param realm\n     * @param target\n     * @param userAssertionHash\n     * @param tokenType\n     */\n    private getCredentialsFilteredByInternal(\n        homeAccountId?: string,\n        environment?: string,\n        credentialType?: string,\n        clientId?: string,\n        familyId?: string,\n        realm?: string,\n        target?: string,\n        userAssertionHash?: string,\n        tokenType?: AuthenticationScheme,\n        keyId?: string,\n        requestedClaimsHash?: string\n    ): CredentialCache {\n        const allCacheKeys = this.getKeys();\n        const matchingCredentials: CredentialCache = {\n            idTokens: {},\n            accessTokens: {},\n            refreshTokens: {},\n        };\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-credential type cache entities\n            const credType = CredentialEntity.getCredentialType(cacheKey);\n\n            if (credType === Constants.NOT_DEFINED) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getSpecificCredential(cacheKey, credType);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!userAssertionHash && !this.matchUserAssertionHash(entity, userAssertionHash)) {\n                return;\n            }\n\n            /*\n             * homeAccountId can undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n             * because we don't want a client_credential request to return a cached token that has a homeAccountId\n             */\n            if ((typeof homeAccountId === \"string\") && !this.matchHomeAccountId(entity, homeAccountId)) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!realm && !this.matchRealm(entity, realm)) {\n                return;\n            }\n\n            if (!!credentialType && !this.matchCredentialType(entity, credentialType)) {\n                return;\n            }\n\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n\n            if (!!familyId && !this.matchFamilyId(entity, familyId)) {\n                return;\n            }\n\n            /*\n             * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n             * Resource specific refresh tokens case will be added when the support is deemed necessary\n             */\n            if (!!target && !this.matchTarget(entity, target)) {\n                return;\n            }\n\n            // If request OR cached entity has requested Claims Hash, check if they match\n            if (requestedClaimsHash || entity.requestedClaimsHash) {\n                // Don't match if either is undefined or they are different\n                if (entity.requestedClaimsHash !== requestedClaimsHash) {\n                    return;\n                }\n            }\n\n            // Access Token with Auth Scheme specific matching\n            if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n                if(!!tokenType && !this.matchTokenType(entity, tokenType)) {\n                    return;\n                }\n\n                // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n                if (tokenType === AuthenticationScheme.SSH) {\n                    if(keyId && !this.matchKeyId(entity, keyId)) {\n                        return;\n                    }\n                }\n            }\n\n            // At this point, the entity matches the request, update cache key if key schema has changed\n            const updatedCacheKey = this.updateCredentialCacheKey(cacheKey, entity);\n\n            switch (credType) {\n                case CredentialType.ID_TOKEN:\n                    matchingCredentials.idTokens[updatedCacheKey] = entity as IdTokenEntity;\n                    break;\n                case CredentialType.ACCESS_TOKEN:\n                case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                    matchingCredentials.accessTokens[updatedCacheKey] = entity as AccessTokenEntity;\n                    break;\n                case CredentialType.REFRESH_TOKEN:\n                    matchingCredentials.refreshTokens[updatedCacheKey] = entity as RefreshTokenEntity;\n                    break;\n            }\n        });\n\n        return matchingCredentials;\n    }\n\n    /**\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n     * @param filter\n     */\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\n        return this.getAppMetadataFilteredByInternal(\n            filter.environment,\n            filter.clientId,\n        );\n    }\n\n    /**\n     * Support function to help match appMetadata\n     * @param environment\n     * @param clientId\n     */\n    private getAppMetadataFilteredByInternal(\n        environment?: string,\n        clientId?: string\n    ): AppMetadataCache {\n\n        const allCacheKeys = this.getKeys();\n        const matchingAppMetadata: AppMetadataCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-appMetadata type cache entities\n            if (!this.isAppMetadata(cacheKey)) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAppMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n\n            matchingAppMetadata[cacheKey] = entity;\n\n        });\n\n        return matchingAppMetadata;\n    }\n\n    /**\n     * retrieve authorityMetadata that contains a matching alias\n     * @param filter\n     */\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\n        const allCacheKeys = this.getAuthorityMetadataKeys();\n        let matchedEntity = null;\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-authorityMetadata type cache entities\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAuthorityMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (entity.aliases.indexOf(host) === -1) {\n                return;\n            }\n\n            matchedEntity = entity;\n\n        });\n\n        return matchedEntity;\n    }\n\n    /**\n     * Removes all accounts and related tokens from cache.\n     */\n    async removeAllAccounts(): Promise<boolean> {\n        const allCacheKeys = this.getKeys();\n        const removedAccounts: Array<Promise<boolean>> = [];\n\n        allCacheKeys.forEach((cacheKey) => {\n            const entity = this.getAccount(cacheKey);\n            if (!entity) {\n                return;\n            }\n            removedAccounts.push(this.removeAccount(cacheKey));\n        });\n\n        await Promise.all(removedAccounts);\n        return true;\n    }\n\n    /**\n     * returns a boolean if the given account is removed\n     * @param account\n     */\n    async removeAccount(accountKey: string): Promise<boolean> {\n        const account = this.getAccount(accountKey);\n        if (!account) {\n            throw ClientAuthError.createNoAccountFoundError();\n        }\n        return (await this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT));\n    }\n\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    async removeAccountContext(account: AccountEntity): Promise<boolean> {\n        const allCacheKeys = this.getKeys();\n        const accountId = account.generateAccountId();\n        const removedCredentials: Array<Promise<boolean>> = [];\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-credential type cache entities\n            const credType = CredentialEntity.getCredentialType(cacheKey);\n            if (credType === Constants.NOT_DEFINED) {\n                return;\n            }\n\n            const cacheEntity = this.getSpecificCredential(cacheKey, credType);\n            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n                removedCredentials.push(this.removeCredential(cacheEntity));\n            }\n        });\n\n        await Promise.all(removedCredentials);\n        return true;\n    }\n\n    /**\n     * returns a boolean if the given credential is removed\n     * @param credential\n     */\n    async removeCredential(credential: CredentialEntity): Promise<boolean> {\n        const key = credential.generateCredentialKey();\n\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\n        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n            if(credential.tokenType === AuthenticationScheme.POP) {\n                const accessTokenWithAuthSchemeEntity = credential as AccessTokenEntity;\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\n\n                if (kid) {\n                    try {\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\n                    } catch (error) {\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\n                    }\n                }\n            }\n        }\n\n        return this.removeItem(key, CacheSchemaType.CREDENTIAL);\n    }\n\n    /**\n     * Removes all app metadata objects from cache.\n     */\n    removeAppMetadata(): boolean {\n        const allCacheKeys = this.getKeys();\n        allCacheKeys.forEach((cacheKey) => {\n            if (this.isAppMetadata(cacheKey)) {\n                this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n            }\n        });\n\n        return true;\n    }\n\n    /**\n     * Retrieve the cached credentials into a cacherecord\n     * @param account\n     * @param clientId\n     * @param scopes\n     * @param environment\n     * @param authScheme\n     */\n    readCacheRecord(account: AccountInfo, clientId: string, request: BaseAuthRequest, environment: string): CacheRecord {\n\n        const cachedAccount = this.readAccountFromCache(account);\n        const cachedIdToken = this.readIdTokenFromCache(clientId, account);\n        const cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\n        const cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n\n        if (cachedAccount && cachedIdToken) {\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n        }\n\n        return {\n            account: cachedAccount,\n            idToken: cachedIdToken,\n            accessToken: cachedAccessToken,\n            refreshToken: cachedRefreshToken,\n            appMetadata: cachedAppMetadata,\n        };\n    }\n\n    /**\n     * Retrieve AccountEntity from cache\n     * @param account\n     */\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\n        return this.getAccount(accountKey);\n    }\n\n    /**\n     * Retrieve AccountEntity from cache\n     * @param nativeAccountId\n     * @returns AccountEntity or Null\n     */\n    readAccountFromCacheWithNativeAccountId(nativeAccountId: string): AccountEntity | null {\n        // fetch account from memory\n        const accountFilter: AccountFilter = {\n            nativeAccountId\n        };\n        const accountCache: AccountCache = this.getAccountsFilteredBy(accountFilter);\n        const accounts = Object.keys(accountCache).map((key) => accountCache[key]);\n\n        if (accounts.length < 1) {\n            return null;\n        } else if (accounts.length > 1) {\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n        }\n\n        return accounts[0];\n    }\n\n    /**\n     * Retrieve IdTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param inputRealm\n     */\n    readIdTokenFromCache(clientId: string, account: AccountInfo): IdTokenEntity | null {\n        const idTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: clientId,\n            realm: account.tenantId,\n        };\n\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n        const idTokens = Object.keys(credentialCache.idTokens).map((key) => credentialCache.idTokens[key]);\n        const numIdTokens = idTokens.length;\n\n        if (numIdTokens < 1) {\n            return null;\n        } else if (numIdTokens > 1) {\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n        }\n\n        return idTokens[0] as IdTokenEntity;\n    }\n\n    /**\n     * Retrieve AccessTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param scopes\n     * @param authScheme\n     */\n    readAccessTokenFromCache(clientId: string, account: AccountInfo, request: BaseAuthRequest): AccessTokenEntity | null {\n        const scopes =  new ScopeSet(request.scopes || []);\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n\n        const accessTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: credentialType,\n            clientId,\n            realm: account.tenantId,\n            target: scopes.printScopesLowerCase(),\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash,\n        };\n\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n\n        const accessTokens = Object.keys(credentialCache.accessTokens).map((key) => credentialCache.accessTokens[key]);\n\n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            return null;\n        } else if (numAccessTokens > 1) {\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n        }\n\n        return accessTokens[0] as AccessTokenEntity;\n    }\n\n    /**\n     * Helper to retrieve the appropriate refresh token from cache\n     * @param clientId\n     * @param account\n     * @param familyRT\n     */\n    readRefreshTokenFromCache(clientId: string, account: AccountInfo, familyRT: boolean): RefreshTokenEntity | null {\n        const id = familyRT ? THE_FAMILY_ID : undefined;\n        const refreshTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.REFRESH_TOKEN,\n            clientId: clientId,\n            familyId: id,\n        };\n\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n        const refreshTokens = Object.keys(credentialCache.refreshTokens).map((key) => credentialCache.refreshTokens[key]);\n\n        const numRefreshTokens = refreshTokens.length;\n        if (numRefreshTokens < 1) {\n            return null;\n        }\n        // address the else case after remove functions address environment aliases\n\n        return refreshTokens[0] as RefreshTokenEntity;\n    }\n\n    /**\n     * Retrieve AppMetadataEntity from cache\n     */\n    readAppMetadataFromCache(environment: string, clientId: string): AppMetadataEntity | null {\n        const appMetadataFilter: AppMetadataFilter = {\n            environment,\n            clientId,\n        };\n\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\n\n        const numAppMetadata = appMetadataEntries.length;\n        if (numAppMetadata < 1) {\n            return null;\n        } else if (numAppMetadata > 1) {\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n        }\n\n        return appMetadataEntries[0] as AppMetadataEntity;\n    }\n\n    /**\n     * Return the family_id value associated  with FOCI\n     * @param environment\n     * @param clientId\n     */\n    isAppMetadataFOCI(environment: string, clientId: string): boolean {\n        const appMetadata = this.readAppMetadataFromCache(environment, clientId);\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n    }\n\n    /**\n     * helper to match account ids\n     * @param value\n     * @param homeAccountId\n     */\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\n        return !!((typeof entity.homeAccountId === \"string\") && (homeAccountId === entity.homeAccountId));\n    }\n\n    /**\n     * helper to match assertion\n     * @param value\n     * @param oboAssertion\n     */\n    private matchUserAssertionHash(entity: CredentialEntity, userAssertionHash: string): boolean {\n        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n    }\n\n    /**\n     * helper to match environment\n     * @param value\n     * @param environment\n     */\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * helper to match credential type\n     * @param entity\n     * @param credentialType\n     */\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\n    }\n\n    /**\n     * helper to match client ids\n     * @param entity\n     * @param clientId\n     */\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\n        return !!(entity.clientId && clientId === entity.clientId);\n    }\n\n    /**\n     * helper to match family ids\n     * @param entity\n     * @param familyId\n     */\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\n        return !!(entity.familyId && familyId === entity.familyId);\n    }\n\n    /**\n     * helper to match realm\n     * @param entity\n     * @param realm\n     */\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\n        return !!(entity.realm && realm === entity.realm);\n    }\n\n    /**\n     * helper to match nativeAccountId\n     * @param entity\n     * @param nativeAccountId\n     * @returns boolean indicating the match result\n     */\n    private matchNativeAccountId(entity: AccountEntity, nativeAccountId: string): boolean {\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n    }\n\n    /**\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n     * @param entity\n     * @param target\n     */\n    private matchTarget(entity: CredentialEntity, target: string): boolean {\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n\n        if ( isNotAccessTokenCredential || !entity.target) {\n            return false;\n        }\n\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\n        const requestTargetScopeSet: ScopeSet = ScopeSet.fromString(target);\n\n        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n        } else {\n            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n        }\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n    }\n\n    /**\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchTokenType(entity: CredentialEntity, tokenType: AuthenticationScheme): boolean {\n        return !!(entity.tokenType && entity.tokenType === tokenType);\n    }\n\n    /**\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\n        return !!(entity.keyId && entity.keyId === keyId);\n    }\n\n    /**\n     * returns if a given cache entity is of the type appmetadata\n     * @param key\n     */\n    private isAppMetadata(key: string): boolean {\n        return key.indexOf(APP_METADATA) !== -1;\n    }\n\n    /**\n     * returns if a given cache entity is of the type authoritymetadata\n     * @param key\n     */\n    protected isAuthorityMetadata(key: string): boolean {\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n    }\n\n    /**\n     * returns cache key used for cloud instance metadata\n     */\n    generateAuthorityMetadataCacheKey(authority: string): string {\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n    }\n\n    /**\n     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\n     * @param key\n     * @param credType\n     */\n    private getSpecificCredential(key: string, credType: string): ValidCredentialType | null {\n        switch (credType) {\n            case CredentialType.ID_TOKEN: {\n                return this.getIdTokenCredential(key);\n            }\n            case CredentialType.ACCESS_TOKEN:\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {\n                return this.getAccessTokenCredential(key);\n            }\n            case CredentialType.REFRESH_TOKEN: {\n                return this.getRefreshTokenCredential(key);\n            }\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Helper to convert serialized data to object\n     * @param obj\n     * @param json\n     */\n    static toObject<T>(obj: T, json: object): T {\n        for (const propertyName in json) {\n            obj[propertyName] = json[propertyName];\n        }\n        return obj;\n    }\n}\n\nexport class DefaultStorageClass extends CacheManager {\n    setAccount(): void {\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccount(): AccountEntity {\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setIdTokenCredential(): void {\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getIdTokenCredential(): IdTokenEntity {\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAccessTokenCredential(): void {\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccessTokenCredential(): AccessTokenEntity {\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setRefreshTokenCredential(): void {\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getRefreshTokenCredential(): RefreshTokenEntity {\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAppMetadata(): void {\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAppMetadata(): AppMetadataEntity {\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setServerTelemetry(): void {\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getServerTelemetry(): ServerTelemetryEntity {\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAuthorityMetadata(): void {\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadataKeys(): Array<string> {\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setThrottlingCache(): void {\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getThrottlingCache(): ThrottlingEntity {\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    removeItem(): boolean {\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    containsKey(): boolean {\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getKeys(): string[] {\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    async clear(): Promise<void> {\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    updateCredentialCacheKey(): string {\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n}\n"],"names":[],"mappings":"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